#Level 4

Event emitters, event requests, event listening



# Event Emitters


The callback patterns is good for operations that either succeed or fail.


But what if we have an object that changes state over time? On each state change, that object emits an event.

```js
emitter.on('event', function(payload) {
  console.log('it happened!');
});
```


More practical example:

```js
door.on('open', function onDoorOpen(photo) {
  console.log('door opened');
});

door.on('close', function onDoorClose(photo) {
  console.log('door closed');
});
```

Elements:

* emitter: `door`
* event type: `open` and `close`
* listener: `onDoorOpen` and `onDoorClose` functions
* payload: `photo`


## multiple listeners

An emitter can have multiple listeners for the same event type

```js
bell.on('ring', function() {
  console.log('RING!!!!');
});

door.on('open', function() {
  console.log('Bell rang');
});
```


## .removeListener

You can unregister an event listener:

```js
function onRing() {
    console.log('RING!!!');
}

door.on('ring', onRing);

...

door.removeListener('ring', onRing);
```


## .once

Using `.once` you can listen to an event at most once:

```js
door.once('ring', function() { 
  console.log('I think it\'s Jake at the door`);
});
```


# Create an event emitter

```js
var EventEmitter = require('events').EventEmitter;

var clock = new EventEmitter();
```



## Exercise 4.1

Create a module that exports an event emitter that emits:

* a `tic` event
* 1 second later
* a `toc` event
* 1 second later, repeat
* Each event has a payload of the current timestamp (ms)


one solution:

```js
// clock.js
var EventEmitter = require('events').EventEmitter;

var clock = new EventEmitter();

var tic = true;

setInterval(function() {
  clock.emit(tic ? 'tic' : 'toc', Date.now());
  tic = !tic;
}, 1e3);

module.exports = clock;
```